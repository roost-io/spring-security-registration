// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=authProvider_7ad301fa6d
ROOST_METHOD_SIG_HASH=authProvider_d88ae3e376

Here are the JUnit test scenarios for the provided authProvider() method:

Scenario 1: Successful Authentication

Details:
  TestName: successfulAuthentication()
  Description: This test verifies that the authProvider successfully authenticates a user with valid credentials and performs post-authentication checks.
Execution:
  Arrange:
    - Create a mock UserDetailsService that returns a valid UserDetails object for a given username.
    - Create a mock DifferentLocationChecker that returns true for post-authentication checks.
  Act:
    - Invoke the authProvider() method to get an instance of CustomAuthenticationProvider.
    - Set the mock UserDetailsService and DifferentLocationChecker in the authProvider.
    - Call the authenticate() method of the authProvider with valid user credentials.
  Assert:
    - Assert that the authenticate() method returns a non-null Authentication object.
    - Assert that the returned Authentication object contains the expected user details.
Validation:
  The assertion verifies that the authProvider successfully authenticates a user with valid credentials and performs post-authentication checks. It ensures that the authentication process works as expected when the provided credentials are correct and the user passes the location checks.

Scenario 2: Authentication Failure - Invalid Credentials

Details:
  TestName: authenticationFailureInvalidCredentials()
  Description: This test verifies that the authProvider correctly handles authentication failure when invalid credentials are provided.
Execution:
  Arrange:
    - Create a mock UserDetailsService that throws a UsernameNotFoundException for a given invalid username.
  Act:
    - Invoke the authProvider() method to get an instance of CustomAuthenticationProvider.
    - Set the mock UserDetailsService in the authProvider.
    - Call the authenticate() method of the authProvider with invalid user credentials.
  Assert:
    - Assert that the authenticate() method throws a BadCredentialsException.
Validation:
  The assertion verifies that the authProvider correctly handles authentication failure when invalid credentials are provided. It ensures that the authentication process throws the appropriate exception when the username or password is incorrect.

Scenario 3: Authentication Failure - Different Location

Details:
  TestName: authenticationFailureDifferentLocation()
  Description: This test verifies that the authProvider correctly handles authentication failure when the user's location doesn't match the expected location during post-authentication checks.
Execution:
  Arrange:
    - Create a mock UserDetailsService that returns a valid UserDetails object for a given username.
    - Create a mock DifferentLocationChecker that returns false for post-authentication checks.
  Act:
    - Invoke the authProvider() method to get an instance of CustomAuthenticationProvider.
    - Set the mock UserDetailsService and DifferentLocationChecker in the authProvider.
    - Call the authenticate() method of the authProvider with valid user credentials.
  Assert:
    - Assert that the authenticate() method throws an AuthenticationException.
Validation:
  The assertion verifies that the authProvider correctly handles authentication failure when the user's location doesn't match the expected location during post-authentication checks. It ensures that the authentication process fails and throws an exception when the location check fails, even if the credentials are valid.

Scenario 4: Password Encoding

Details:
  TestName: passwordEncoding()
  Description: This test verifies that the authProvider uses the configured password encoder to encode and compare passwords during authentication.
Execution:
  Arrange:
    - Create a mock UserDetailsService that returns a UserDetails object with an encoded password.
    - Create a mock PasswordEncoder that encodes the password and verifies the encoded password.
  Act:
    - Invoke the authProvider() method to get an instance of CustomAuthenticationProvider.
    - Set the mock UserDetailsService and PasswordEncoder in the authProvider.
    - Call the authenticate() method of the authProvider with user credentials.
  Assert:
    - Assert that the PasswordEncoder's encode() method is called with the provided password.
    - Assert that the PasswordEncoder's matches() method is called with the provided password and the encoded password.
Validation:
  The assertion verifies that the authProvider uses the configured password encoder to encode and compare passwords during authentication. It ensures that the password encoding and comparison process is properly integrated into the authentication flow.

These test scenarios cover different aspects of the authProvider() method, including successful authentication, authentication failure due to invalid credentials or different location, and password encoding. They help ensure the correctness and robustness of the authentication process implemented by the CustomAuthenticationProvider.
*/

// ********RoostGPT********
package com.baeldung.spring;

import com.baeldung.security.google2fa.CustomAuthenticationProvider;
import com.baeldung.security.location.DifferentLocationChecker;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class SecSecurityConfigAuthProviderTest {

	@Mock
	private UserDetailsService userDetailsService;

	@Mock
	private PasswordEncoder passwordEncoder;

	@Mock
	private DifferentLocationChecker differentLocationChecker;

	@InjectMocks
	private SecSecurityConfig secSecurityConfig;

	private CustomAuthenticationProvider authProvider;

	@BeforeEach
	void setUp() {
		authProvider = (CustomAuthenticationProvider) secSecurityConfig.authProvider();
	}

	@Test
	void successfulAuthentication() {
		// Arrange
		String username = "testuser";
		String password = "password";
		UserDetails userDetails = mock(UserDetails.class);
		when(userDetailsService.loadUserByUsername(username)).thenReturn(userDetails);
		when(passwordEncoder.matches(password, userDetails.getPassword())).thenReturn(true);
		when(differentLocationChecker.check(any(Authentication.class))).thenReturn(true);
		// Act
		Authentication result = authProvider.authenticate(new UsernamePasswordAuthenticationToken(username, password));
		// Assert
		assertNotNull(result);
		assertEquals(userDetails, result.getPrincipal());
		verify(userDetailsService).loadUserByUsername(username);
		verify(passwordEncoder).matches(password, userDetails.getPassword());
		verify(differentLocationChecker).check(result);
	}

	@Test
	void authenticationFailureInvalidCredentials() {
		// Arrange
		String username = "testuser";
		String password = "wrongpassword";
		when(userDetailsService.loadUserByUsername(username))
			.thenThrow(new UsernameNotFoundException("User not found"));
		// Act & Assert
		assertThrows(BadCredentialsException.class,
				() -> authProvider.authenticate(new UsernamePasswordAuthenticationToken(username, password)));
		verify(userDetailsService).loadUserByUsername(username);
		verifyNoInteractions(passwordEncoder);
		verifyNoInteractions(differentLocationChecker);
	}

	@Test
	void authenticationFailureDifferentLocation() {
		// Arrange
		String username = "testuser";
		String password = "password";
		UserDetails userDetails = mock(UserDetails.class);
		when(userDetailsService.loadUserByUsername(username)).thenReturn(userDetails);
		when(passwordEncoder.matches(password, userDetails.getPassword())).thenReturn(true);
		when(differentLocationChecker.check(any(Authentication.class))).thenReturn(false);
		// Act & Assert
		assertThrows(AuthenticationException.class,
				() -> authProvider.authenticate(new UsernamePasswordAuthenticationToken(username, password)));
		verify(userDetailsService).loadUserByUsername(username);
		verify(passwordEncoder).matches(password, userDetails.getPassword());
		verify(differentLocationChecker).check(any(Authentication.class));
	}

	@Test
	void passwordEncoding() {
		// Arrange
		String username = "testuser";
		String password = "password";
		String encodedPassword = "encodedPassword";
		UserDetails userDetails = mock(UserDetails.class);
		when(userDetails.getPassword()).thenReturn(encodedPassword);
		when(userDetailsService.loadUserByUsername(username)).thenReturn(userDetails);
		when(passwordEncoder.matches(password, encodedPassword)).thenReturn(true);
		when(differentLocationChecker.check(any(Authentication.class))).thenReturn(true);
		// Act
		authProvider.authenticate(new UsernamePasswordAuthenticationToken(username, password));
		// Assert
		verify(passwordEncoder).matches(password, encodedPassword);
	}

}
