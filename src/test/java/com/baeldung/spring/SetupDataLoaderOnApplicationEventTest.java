// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=onApplicationEvent_4794b9820e
ROOST_METHOD_SIG_HASH=onApplicationEvent_69d07a5223

Here are the JUnit test scenarios for the provided onApplicationEvent method:

Scenario 1: Application Event Handled Successfully

Details:
  TestName: applicationEventHandledSuccessfully
  Description: This test verifies that the onApplicationEvent method executes successfully when the alreadySetup flag is false, creating initial privileges, roles, and a user.
Execution:
  Arrange: Set alreadySetup to false. Mock the necessary repository methods to return the expected privileges, roles, and user.
  Act: Invoke the onApplicationEvent method with a mocked ContextRefreshedEvent.
  Assert: Verify that the createPrivilegeIfNotFound, createRoleIfNotFound, and createUserIfNotFound methods are called with the expected arguments using Mockito's verify method.
Validation:
  The assertion ensures that the initial setup process is triggered when alreadySetup is false, and the required privileges, roles, and user are created. This test validates the proper initialization of the application's security setup.

Scenario 2: Application Event Skipped When Already Set Up

Details:
  TestName: applicationEventSkippedWhenAlreadySetUp
  Description: This test verifies that the onApplicationEvent method returns immediately without performing any setup when the alreadySetup flag is true.
Execution:
  Arrange: Set alreadySetup to true.
  Act: Invoke the onApplicationEvent method with a mocked ContextRefreshedEvent.
  Assert: Verify that none of the createPrivilegeIfNotFound, createRoleIfNotFound, and createUserIfNotFound methods are called using Mockito's verify method with never().
Validation:
  The assertion confirms that the setup process is skipped when alreadySetup is true, preventing unnecessary initialization. This test ensures that the application doesn't perform redundant setup on subsequent context refreshes.

Scenario 3: Privilege Creation

Details:
  TestName: privilegeCreationIfNotFound
  Description: This test verifies that the createPrivilegeIfNotFound method creates a new privilege if it doesn't exist in the database.
Execution:
  Arrange: Mock the privilegeRepository to return null when findByName is called with a specific privilege name.
  Act: Invoke the createPrivilegeIfNotFound method with the mocked privilege name.
  Assert: Verify that the privilegeRepository's save method is called with a new Privilege object containing the specified name.
Validation:
  The assertion ensures that a new privilege is created and saved when it doesn't exist in the database. This test validates the proper creation of initial privileges during application setup.

Scenario 4: Role Creation

Details:
  TestName: roleCreationIfNotFound
  Description: This test verifies that the createRoleIfNotFound method creates a new role with the specified privileges if it doesn't exist in the database.
Execution:
  Arrange: Mock the roleRepository to return null when findByName is called with a specific role name. Create a list of mocked privileges.
  Act: Invoke the createRoleIfNotFound method with the mocked role name and privileges.
  Assert: Verify that the roleRepository's save method is called with a new Role object containing the specified name and privileges.
Validation:
  The assertion ensures that a new role is created and saved with the provided privileges when it doesn't exist in the database. This test validates the proper creation of initial roles during application setup.

Scenario 5: User Creation

Details:
  TestName: userCreationIfNotFound
  Description: This test verifies that the createUserIfNotFound method creates a new user with the specified email, firstName, lastName, password, and roles if it doesn't exist in the database.
Execution:
  Arrange: Mock the userRepository to return null when findByEmail is called with a specific email. Create a list of mocked roles. Mock the passwordEncoder to return the encoded password.
  Act: Invoke the createUserIfNotFound method with the mocked email, firstName, lastName, password, and roles.
  Assert: Verify that the userRepository's save method is called with a new User object containing the specified email, firstName, lastName, encoded password, and roles.
Validation:
  The assertion ensures that a new user is created and saved with the provided details when it doesn't exist in the database. This test validates the proper creation of the initial user during application setup.

These test scenarios cover the main functionality of the onApplicationEvent method and its associated helper methods. They ensure that the application setup process is triggered correctly, privileges, roles, and users are created as expected, and the setup is skipped when already performed. The tests validate the proper initialization of the application's security setup based on the provided configuration.
*/

// ********RoostGPT********
package com.baeldung.spring;

import com.baeldung.persistence.dao.PrivilegeRepository;
import com.baeldung.persistence.dao.RoleRepository;
import com.baeldung.persistence.dao.UserRepository;
import com.baeldung.persistence.model.Privilege;
import com.baeldung.persistence.model.Role;
import com.baeldung.persistence.model.User;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.security.crypto.password.PasswordEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.util.Collection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@RunWith(MockitoJUnitRunner.class)
public class SetupDataLoaderOnApplicationEventTest {

	@Mock
	private UserRepository userRepository;

	@Mock
	private RoleRepository roleRepository;

	@Mock
	private PrivilegeRepository privilegeRepository;

	@Mock
	private PasswordEncoder passwordEncoder;

	@InjectMocks
	private SetupDataLoader setupDataLoader;

	@Before
	public void setUp() {
		// Modify the access level of alreadySetup to package-private or protected for
		// testing
		setupDataLoader.setAlreadySetup(false);
	}

	@Test
	public void applicationEventHandledSuccessfully() {
		// Arrange
		Privilege readPrivilege = new Privilege("READ_PRIVILEGE");
		Privilege writePrivilege = new Privilege("WRITE_PRIVILEGE");
		Privilege passwordPrivilege = new Privilege("CHANGE_PASSWORD_PRIVILEGE");
		Role adminRole = new Role("ROLE_ADMIN");
		Role userRole = new Role("ROLE_USER");
		User user = new User();
		when(privilegeRepository.findByName("READ_PRIVILEGE")).thenReturn(null);
		when(privilegeRepository.findByName("WRITE_PRIVILEGE")).thenReturn(null);
		when(privilegeRepository.findByName("CHANGE_PASSWORD_PRIVILEGE")).thenReturn(null);
		when(privilegeRepository.save(any(Privilege.class))).thenReturn(readPrivilege, writePrivilege,
				passwordPrivilege);
		when(roleRepository.findByName("ROLE_ADMIN")).thenReturn(null);
		when(roleRepository.findByName("ROLE_USER")).thenReturn(null);
		when(roleRepository.save(any(Role.class))).thenReturn(adminRole, userRole);
		when(userRepository.findByEmail("test@test.com")).thenReturn(null);
		when(userRepository.save(any(User.class))).thenReturn(user);
		// Act
		setupDataLoader.onApplicationEvent(mock(ContextRefreshedEvent.class));
		// Assert
		verify(privilegeRepository, times(3)).save(any(Privilege.class));
		verify(roleRepository, times(2)).save(any(Role.class));
		verify(userRepository, times(1)).save(any(User.class));
		assert setupDataLoader.isAlreadySetup();
	}

	@Test
	public void applicationEventSkippedWhenAlreadySetUp() {
		// Arrange
		setupDataLoader.setAlreadySetup(true);
		// Act
		setupDataLoader.onApplicationEvent(mock(ContextRefreshedEvent.class));
		// Assert
		verify(privilegeRepository, never()).save(any(Privilege.class));
		verify(roleRepository, never()).save(any(Role.class));
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	public void privilegeCreationIfNotFound() {
		// Arrange
		String privilegeName = "TEST_PRIVILEGE";
		Privilege privilege = new Privilege(privilegeName);
		when(privilegeRepository.findByName(privilegeName)).thenReturn(null);
		when(privilegeRepository.save(any(Privilege.class))).thenReturn(privilege);
		// Act
		Privilege result = setupDataLoader.createPrivilegeIfNotFound(privilegeName);
		// Assert
		verify(privilegeRepository, times(1)).save(any(Privilege.class));
		assert result.getName().equals(privilegeName);
	}

	@Test
	public void roleCreationIfNotFound() {
		// Arrange
		String roleName = "TEST_ROLE";
		List<Privilege> privileges = new ArrayList<>();
		Role role = new Role(roleName);
		when(roleRepository.findByName(roleName)).thenReturn(null);
		when(roleRepository.save(any(Role.class))).thenReturn(role);
		// Act
		Role result = setupDataLoader.createRoleIfNotFound(roleName, privileges);
		// Assert
		verify(roleRepository, times(1)).save(any(Role.class));
		assert result.getName().equals(roleName);
		assert result.getPrivileges().equals(privileges);
	}

	@Test
	public void userCreationIfNotFound() {
		// Arrange
		String email = "test@example.com";
		String firstName = "John";
		String lastName = "Doe";
		String password = "password";
		List<Role> roles = Arrays.asList(new Role("ROLE_USER"));
		User user = new User();
		user.setEmail(email);
		user.setFirstName(firstName);
		user.setLastName(lastName);
		user.setPassword(password);
		user.setRoles(roles);
		when(userRepository.findByEmail(email)).thenReturn(null);
		when(passwordEncoder.encode(password)).thenReturn("encodedPassword");
		when(userRepository.save(any(User.class))).thenReturn(user);
		// Act
		User result = setupDataLoader.createUserIfNotFound(email, firstName, lastName, password, roles);
		// Assert
		verify(userRepository, times(1)).save(any(User.class));
		assert result.getEmail().equals(email);
		assert result.getFirstName().equals(firstName);
		assert result.getLastName().equals(lastName);
		assert result.getPassword().equals("encodedPassword");
		assert result.getRoles().equals(roles);
	}

}
